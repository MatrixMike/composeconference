{ "times": [
  { "time": "8:30am" , "name": "<hr />" , "id": "t-8300", "title": "Registration", "break": true},

  { "time": "9:00am" ,
    "name": "Lyndon Maydwell" ,
    "id": "introduction",
    "title": "Introduction by the Committee",
    "details": "Welcome to Compose :: Melbourne!",
    "committee": true},

  { "time": "9:30am" ,
    "name": "Andrew Sorensen" ,
    "id": "andrew_sorensen",
    "title": "Keynote - Sound Synthesis in the Computational Crucible",
    "level": 1, 
    "img": "/assets/img/2017-melbourne/andrew_sorensen.jpg",
    "details": "
    <p>A crucible allows base metals to be mixed together at high temperatures to form alloys.
    Medieval alchemists used crucibles to mix an astonishing variety of substances together
    in the search for new materials. While Alchemy is often derided for its informal approach,
    early Alchemists paved the wave for modern chemistry, and included Newton and
    Boyle among their number.</p>
    <p>Just as the crucible encouraged an experimental and experiential approach to
    understanding the world, so too the computer can provide a computational crucible.
    Code can be mixed and brought to great temperature in the search for greater
    understanding and new discovery.</p>
    <p>Using his own Extempore programming language Andrew will provide a 'live' introduction
    to sound synthesis, building up the core components of a real-time digital synthesizer
    on-the-fly 'in the computational crucible'.</p>
    ",
    "bio": "
    <p>
    Andrew Sorensen is an artist, a programmer, and a computer scientist. His interests are diverse, but unify under a common theme
    - the programming language as an interface for real-time dialogue between human, machine, and environment. In exploring these
    ideas Andrew is as likely to be found hacking code in nightclubs as steering scientific codes on distributed high performance
    computing clusters.  Andrew is well known for creating the programming languages that he uses in live performance to generate
    audiovisual theatre. He is the author of the Extempore programming language - a systems programming language designed for
    high-performance 'live' programming.</p>
    "
  },
  {"time": "10:15am",
    "title": "Break",
    "name": "<hr />",
    "id": "break1",
    "break": true},
  {"time": "10:30",
    "name": "Andrew McCluskey",
    "id": "andrew_mccluskey",
    "img": "/assets/img/2017-melbourne/andrew_mccluskey.jpg",
    "title": "Your first Haskell app",
    "level": 1, 
    "bio": "
      Andrew is a functional programming engineer at Data61. Earlier in his career he worked across a range of domains 
      using conventional imperative programming languages, growing more and more frustrated with the difficulties 
      of reasoning in a stateful and often untyped world. After hearing the claims that functional programming offered 
      solutions to these problems, he embarked on learning Clojure - having fond memories of his first year programming 
      course in Scheme. Convinced that FP was a good choice, but being burned by a lack of types, Andrew then 
      switched his focus to Haskell and hasn't looked back since.
    ",
    "details": "
      <p>When learning a new programming language there is almost always a leap from learning to applying 
         your knowledge. This leap can be quite large when learning Haskell for a number of reasons. 
         One reason is the dramatic difference between Haskell's style of programming compared to more common 
         imperative languages that many learners are more familiar with. As a consequence, a difficulty for those 
         new to Haskell is identifying when and how to apply the concepts they've learned when writing an 
         application. Another is navigating the Haskell ecosystem; including finding packages and understanding 
         how they work. Finally, some newcomers may delay writing their first application, believing they 
         need to be comfortable with more advanced concepts before they can successfully write useful 
         software. This is not the case. While these abstractions are useful, many of Haskell's benefits 
         can be enjoyed while sticking to its more basic abstractions.</p>

         <p>By referring to a simple example application, we'll demonstrate how and when to apply some 
            core techniques and abstractions, and alleviate the burden of starting an app from scratch. 
            We'll cover a number of data types, type classes, and techniques, including:</p>
         <ul>
	   <li>Effectively using algebraic data types to more precisely model the problem</li>
	   <li>Using applicative parsers to read configuration from the command line or files</li>
	   <li>Using the Monoid type class to merge layers of configuration. e.g. user values merged with defaults</li>
	   <li>Using Maybe in place of null or exceptions to handle missing/optional data</li>
	   <li>Using Either in place of exceptions or return codes to handle failures</li>
	   <li>Using the Monad type class to sequence computations in a particular context, such as IO</li>
         </ul>
         <p>If you've ever been intimidated by the thought of starting a project in Haskell, then this talk will 
            give you a solid place to start. Along the way we'll see that, not only is Haskell a general purpose 
            language that can be used to write everyday applications, but that it brings with it a range of benefits.</p>
    "},
  {"time": "11am",
    "name": "Rahul Trikha",
    "id": "rahul_trikha",
    "title": "From JavaScript to PureScript",
    "level": 1, 
    "details": ""},
  {"time": "11:30am",
    "name": "George Wilson",
    "id": "george_wilson",
    "level": 1,
    "title": "Type Class: The Ultimate Ad Hoc",
    "img": "/assets/img/2017-melbourne/george_wilson.jpg",
    "bio": "
      <p>George Wilson is an enthusiastic functional programmer at the <a href='http://qfpl.io'>Queensland Functional Programming Lab</a>, 
         under Data61/CSIRO, located in Brisbane, Australia.</p> 
      <p>George co-organises the Brisbane Functional Programming Group and enjoys teaching and learning functional programming 
         and related areas of mathematics.</p>
    ",
    "details": "
      <p>Since their inception in Haskell, type classes have become a popular 
        feature of modern functional programming. Indeed, key topics in FP often take the form
	of type classes, such as Monoid and Functor. Many languages developed since
	Haskell have included type classes in their design, such as Idris and Purescript;
	or offered facilities capable of simulating type classes, such as Scala's implicits
	or OCaml's modules.</p>
      <p>In this talk we go beyond the basics with type classes. First we'll differentiate
	between parametric and ad hoc polymorphism, and we'll see why type classes
	are a compelling solution to the latter. By comparing them to other solutions
	- Java interfaces and Scala implicits - we'll see the advantages of type classes.
	In particular, we will focus on why type classes are principled. This section will
	include examples in Java, Scala, and Haskell.</p>
	<p>In order to be principled, there are conditions on the creation of instances:
	there can be a maximum of one instance for a given type for a given type class,
	and it must be in one of two allowed places. We will justify this rigidity by
	discussing instance coherence and its benefits, with examples of incoherence
	silently causing bugs. We will learn what orphan instances are and why they
	can be problematic for coherence.</p>
	<p>Finally, practical guidelines will be given for programmers aiming to simulate
	type classes in other languages, as is popular in the Scala community. These
	guidelines, when followed with discipline, will allow one to recover many of the
	benefits of type classes. Examples in this section will be in Scala.</p>
      <h3>Goal</h3>
        <p>Attendees will leave knowing the difference between parametric 
           and ad hoc polymorphism, and they will understand why type classes 
           are a principled approach to the latter. Attendees wishing to simulate 
           type classes in a capable language, such as Scala, will leave the talk 
           with practical guidelines helping them to do so.</p>
    "
   },
  {"time": "12pm",
    "title": "Lunch",
    "id": "lunch",
    "name": "<hr />",
    "break": true},
  {"time": "1pm",
    "name": "Justin Bedo",
    "id": "justin_bedo",
    "title": "BioShake: a Haskell EDSL for bioinformatics pipelines",
    "level": 2, 
    "details": ""},
  {"time": "1:30pm",
    "name": "Tony Morris",
    "id": "tony_morris",
    "img": "/assets/img/2017-melbourne/tony_morris.jpg",
    "title": "FP in Aviation",
    "level": 2, 
    "bio": "
    <p>Tony Morris is a software engineer for the <a href='http://qfpl.io'>Queensland Functional Programming Lab</a>,
    under Data61/CSIRO, located in Brisbane, Australia. Tony has been deploying functional
    programming solutions for over 10 years, using the Haskell and Scala programming
    languages primarily. Tony teaches functional programming at the tertiary level and
    for professional programmers with a view toward producing a viable commercial result.</p>

    <p>Tony takes a fastidious, principled approach to functional programming both when
    deployed in practice and when in a learning environment to ensure maximum yield
    from the effort. Tony believes that exploring principles and the following
    consequences provides a rewarding experience for all involved.</p>
    ",
    "details": "
    <p>In this talk & demo, we have a look at some of the low-hanging problems in general
    aviation and how functional programming can be applied to provide significant
    improvements in efficiency and air safety. The current solutions to problems
    such as navigation, traffic/terrain collision avoidance and weight/balance
    calculations will be demonstrated to the audience, mostly for amusement. More
    seriously, we will have a look at the legacy that has led to the way things are,
    and how to improve by applying our programming skills.</p>

    <p>We will look at:
    <ul>
    <li>how aviation safety is regulated.</li>
    <li>how aeronautical services are provided to flight operators.</li>
    <li>how aeronautical navigation is conducted and regulated.</li>
    <li>how the weight and balance for a flight is conducted.</li>
    <li>the methods by which aircraft and ground coordinate between each other.</li>
    </ul></p>

   <p>We will see:
    <ul>
    <li>some real (and basic) data management problems in aviation, that very
    obviously threaten safety, then solve them, using programming.</li>
    <li>we will see a live demonstration of aeronautical navigation methods,
    investigate incident reports where lives were lost as a result, and consider
    how our programming skills can yield improvements, possibly even save lives.</li>
    <li>we will conduct a real weight&balance calculation for a flight, then once
    hilarity inevitably ensues, we will look at the problems that arise by this
    method, then solve them using data structures and functional programming. Some
    of these practical problems are obvious, even to a non-aviator, and the
    predictable incident reports are the end result.</li>
    <li>finally, we will have a look at a live demonstration of a software defined
    radio (SDR), receiving ADS-B transmissions from aircraft (live), an AHRS
    implementation and GNSS receiver using off-the-shelf, low-cost parts. We will
    look at why these instruments are helpful to aircraft pilots and interact with
    that device using the Haskell programming language.</li>
    </ul>
    </p>
    "
  },
  {"time": "2pm",
    "name": "Ronen Narkis",
    "id": "ronen_narkis",
    "title": "Re-ops, a Functional Live-Infrastructure as Code",
    "img": "/assets/img/2017-melbourne/ronen_narkis.jpg",
    "level": 2, 
    "bio": "
    <p>Ronen Narkis has been a pro coder for more than 12 years across a variety of projects
    ranging from Devops to Bigdata, using Clojure since 2008 to solve real world problems.</p>

    <p>He enjoys expanding his knowledge about security, operating systems, programming
    languages and any other cool tech he can lay his hands on.</p>
    ",
    "details": "
	<p>The history of live coding environments isn't new, still most of the current tools we use are static in nature 
           and require long cycles of build/compilation/restart both in development and production, the REPL is one of the 
           most productive environments to get instant feedback and have become the standard for contemporary functional languages.</p>

	<p>In this talk we will go through Re-ops, a Clojure based live environment that aims to speed up remote server 
           management, from ad hoc remote operations to metrics collection/reporting up to managing clusters of virtual machines.</p>

	<p>Current configuration management tools (Puppet/Chef/Ansible) are custom environments running on top of 
           Ruby/Python that don't interact (for the most part) with the hosting platform, Re-ops on the other hand is native 
           Clojure and can use any library and language facility.</p>

	<p>Using function composition, protocols and data structures with a dash of macros we create our own core abstractions,
           matching the lisp philosophy of extending the language to match our needs while keeping it simple to extend and use.</p>

	<p>Re-ops is composed from a number of components:</p>

        <ul>
	<li>Re-core: VM management and tracking (AWS, Digital Ocean, KVM), using async job execution.</li>
	<li>Re-mote, remote operations on systems using SSH and ZeroMQ including data collection, aggregation, dashboarding and scheduling.</li>
	<li>Re-gent, remote agent that uses ZeroMQ and connects back to Re-mote, used for high throughput low latency operations (an alternative to SSH).</li>
	<li>Each can be used separately or combined.</li>
        </ul>

	<p>In summary Re-ops offers an alternative for creating infrastructure as code, one in which we can react quickly to a 
           fast changing environment.</p>

	<p>Goals:</p>

        <ul>
	<li>To expose listeners to a different way of thinking with regards to operations (Devops).</li>
	<li>To showcase how to design a system that works well as a live environment both in Clojure (the reload workflow) and the general case.</li>
	<li>Explore protocols, functional composition and pipelines as a base for rapidly changing system.</li>
	<li>How to design the system for explorability</li>
	<li>Cover some interesting libraries used within Re-ops</li>
	<li>Compare Puppet/Chef and show how using Clojure really simplify some problems.</li>
        </ul>

    "
  },
  {"time": "2:30pm",
    "title": "Break",
    "name": "<hr />",
    "id": "break2",
    "break": true},
  {"time": "3pm",
    "name": "Luke Stephenson",
    "id": "luke_stephenson",
    "img": "/assets/img/2017-melbourne/luke_stephenson.jpg",
    "title": "Reactive Streams for REA feeders",
    "level": 2, 
    "bio": "
    Luke Stephenson works as a Lead Developer at REA Group building Scala services
    to power the consumer facing website.  After many years as a Java developer,
    Luke has enjoyed the transition to Scala and becoming a better dev through many FP learnings.
    ",
    "details": "
    <p>This talk introduces Reactive Streams, specifically the Monix implementation and
    how at REA Group we have used it to solve real problems.</p>

    <p>At REA we have many 'feeders' which extract from one data source, perform some
    processing and transformations before loading into a target system.</p>

    <p>Historically these feeders have been built using Java / Scala concurrency primitives
    (e.g. Future / ExecutionContext).  The typical feeder has a very sequential execution
    model like: <br/>
    <ol>
    <li>Read a batch in parallel from the source system. The reading is done in as a parallel batch because the source system may be slow, e.g. an S3 bucket).</li>
    <li>Transform the batch</li>
    <li>Write the batch in parallel to the target system</li>
    </ol> </p>

    And repeat the above until all data is processed.

    <p>The very sequential nature means the feeds are not as performant as they could be.
    The source and target systems were never accessed in parallel.  Writing to the
    target required waiting for the source to read another batch.  And the feeder
    would not read another batch from the source until the target completed.</p>

    <p>Also being based on lower level concurrency primitives, the data pipeline
    is not as easy to visualise from reading the codebase.</p>

    <p>Reactive streams allow us to model asynchronous processing pipelines as a data
    type which can then be executed.  The APIs are declarative, as opposed to the
    legacy solution working with Scala Future and ExecutionContext which resulted
    in immediate evaluation.</p>

    <p>The talk will cover:
    <ul>
    <li>Background into our feeders and legacy implementation</li>
    <li>How the latency involved in that implementation cumulates to affect performance</li>
    <li>Intro to the Monix reactive streams implementation covering the key APIs that we have used</li>
    <li>Demonstrating how the APIs are just data types and that nothing is executed until the observable is consumed and run.</li>
    <li>Code examples for a basic feeder structure</li>
    <li>How the end solution is more performant, but more importantly that the code is more expressive and easy to reason about.</li>
    </ul>
    </p>

    <p>Attendees should leave with a basic understanding of Reactive Streams, and specifically
    how to get started with the Monix implementation of reactive streams.  I'll share a
    working basic project (not REA production code) which provides a basic 'feeder'
    structure for attendees to reference and extend upon if they wish.</p>
    "
  },
  {"time": "3:30pm",
    "name": "Huw Campbell",
    "id": "huw_campbell",
    "img": "/assets/img/2017-melbourne/huw_campbell.jpg",
    "title": "Grenade - Dependently Typed Neural Networks in Haskell",
    "level": 3, 
    "bio": "
      <p>Huw Campbell is a physicist, data scientist, and functional programmer,
        currently working at Ambiata in Sydney. Coming from an academic
	background with a PhD in experimental physics, Huw started working
	as an applied researcher in machine learning in 2014. With Ambiata's
	broad Haskell experience and mentorship, and a strong interest in
	functional programming and type systems, Huw decided to apply these
	principles to machine learning - bringing together these diverse fields.</p>
    ",
    "details": "
	<p>Deep learning and deep neural networks are currently fields of great
	interest and excitement, due to their impressive results in supervised
	and unsupervised machine learning tasks across a broad range of fields
	including computer vision, speech recognition, and games such as Go.</p>

	<p>In this talk, I'll talk about my recent explorations in using type
	level and purely functional programming techniques applied to deep
	learning and neural networks.  We'll run over deep neural networks
	theory, their common architectures, and their various use cases to
	obtain an appreciation for the depth of the field. I'll then show
	how the use of modern Haskell programming allows for these networks
	to be expressed at the type level, providing not only extreme
	concision, but also compile time safety, functional reasoning and
	composition, as well as pretty good runtime performance with a high
	degree of confidence in their correctness.</p>
    "
  },
  {"time": "4pm",
    "title": "Break",
    "name": "<hr />",
    "id": "break3",
    "break": true},
  {"time": "4:15pm",
    "name": "TBA",
    "id": "t-1615",
    "title": "TBA"},
  {"time": "4:45pm",
    "name": "TBA",
    "id": "t-1645",
    "title": "TBA"},
  {"time": "5:15pm",
    "name": "TBA",
    "id": "t-1715",
    "title": "TBA"},
  {"time": "5:45pm",
    "id": "closing",
    "title": "Closing comment",
    "committee": true}

]}

